# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CptViewerDialog
                                 A QGIS plugin
 View Cpt files with QGis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-05
        git sha              : $Format:%H$
        copyright            : (C) 2022 by LeveeLogic
        email                : leveelogic@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import enum
import os
import sys

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtGui

import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.gridspec as gridspec
from matplotlib.figure import Figure, MouseButton
from matplotlib.patches import Polygon

from leveelogic.objects.cpt import Cpt, CptConversionMethod
from leveelogic.objects.soilcollection import SoilCollection
from leveelogic.objects.soilprofile1 import SoilProfile1
from leveelogic.objects.soillayer import SoilLayer

from .database import Database

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "cpt_viewer_dialog_base.ui")
)


class CptViewerDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(CptViewerDialog, self).__init__(parent)
        self.setupUi(self)

        self._iface = iface
        self._figure = None
        self._canvas = None
        self._cpts = []
        self._cpt_ids = []
        self._selected_index = -1
        self._soil_collection = SoilCollection()
        self._database = Database()

        self._initialize_table()
        self._initialize_figure_and_canvas()
        self._connect()

    def _connect(self):
        self.pbFirst.clicked.connect(self.onPbFirstClicked)
        self.pbPrev.clicked.connect(self.onPbPrevClicked)
        self.pbNext.clicked.connect(self.onPbNextClicked)
        self.pbLast.clicked.connect(self.onPbLastClicked)
        self.pbApplyCorrelation.clicked.connect(self.onPbApplyCorrelation)
        self.pbClear.clicked.connect(self.onPbClear)
        self.pbRefresh.clicked.connect(self.onPbRefresh)
        self.pbUpdate.clicked.connect(self.onPbUpdate)        

    def onTwSoillayersCellChanged(self):
        print('nu')
        self._update_figure()

    def onPbUpdate(self):
        """Update the database with the data from the table"""
        cpt_id = self._cpt_ids[self._selected_index]
        sp1 = self._table_to_soilprofile1()
        self._database.add_cpt_interpretation(cpt_id, sp1.to_short_string())

    def onPbClear(self):
        """Clear the table"""
        self.twSoillayers.setRowCount(0)
        self._update_figure()


    def onPbRefresh(self):
        """Refresh the table with the original input"""
        self._update_table_and_figure()

    def _update_table_and_figure(self):        
        cpt_id = self._cpt_ids[self._selected_index]
        sp1 = self._database.get_cpt_interpretation(cpt_id)
        if sp1:
            self._soilprofile_to_table(sp1)            
        else:
            self.twSoillayers.setRowCount(0)        
        
        self._update_figure()        

    def onPbApplyCorrelation(self):
        """Apply the correlation to the cpt"""
        sp1 = self._cpts[self._selected_index].to_soilprofile1(
            cptconversionmethod=CptConversionMethod.ROBERTSON,
            friction_ratio_peat=self.spFrictionRatioPeat.value(),
            minimum_layerheight=self.dspMinLayerHeight.value(),
        )

        # update table
        self.twSoillayers.setRowCount(len(sp1.soillayers))
        self._soilprofile_to_table(sp1)        
        self._update_figure()
        

    def onPbFirstClicked(self):
        self._selected_index = 0
        self._update_table_and_figure()

    def onPbPrevClicked(self):
        if self._selected_index > 0:
            self._selected_index -= 1
            self._update_table_and_figure()

    def onPbNextClicked(self):
        if self._selected_index < len(self._cpts) - 1:
            self._selected_index += 1
            self._update_table_and_figure()

    def onPbLastClicked(self):
        self._selected_index = len(self._cpts) - 1
        self._update_table_and_figure()

    def _initialize_table(self):
        """Set up the table for the soillayers"""
        self.twSoillayers.setColumnCount(3)
        self.twSoillayers.setHorizontalHeaderLabels(["top", "bottom", "soilcode"])

    def _initialize_figure_and_canvas(self):
        """Setup the figure and put it in the frame to display the chosen Cpt"""
        layout = QtWidgets.QVBoxLayout(self.frmCpt)
        self._figure = Figure()
        self._figure.set_tight_layout(True)
        self._canvas = FigureCanvas(self._figure)
        self._figure.canvas.mpl_connect("button_press_event", self.onFigureMouseClicked)
        layout.addWidget(self._canvas)

    def _table_to_soilprofile1(self) -> SoilProfile1:
        sp1 = SoilProfile1()
        for i in range(self.twSoillayers.rowCount()):
            try:
                top = float(self.twSoillayers.item(i, 0).text())
                bottom = float(self.twSoillayers.item(i, 1).text())
                name = self.twSoillayers.cellWidget(i, 2).currentText()
                sp1.soillayers.append(SoilLayer(top=top, bottom=bottom, soilcode=name))
                sp1._merge()
            except Exception as e:
                pass

        return sp1

    def _soilprofile_to_table(self, sp1: SoilProfile1):
        # disconnect the oncellchanged signal while building the table
        self.twSoillayers.disconnect()
        
        soilcodes = [s.code for s in self._soil_collection.soils]
        for i, sl in enumerate(sp1.soillayers):
            self.twSoillayers.setRowCount(len(sp1.soillayers))
            self.twSoillayers.setItem(i, 0, QtWidgets.QTableWidgetItem(f"{sl.top:.2f}"))
            self.twSoillayers.setItem(
                i, 1, QtWidgets.QTableWidgetItem(f"{sl.bottom:.2f}")
            )
            cbSoillayers = QtWidgets.QComboBox()
            cbSoillayers.addItems(soilcodes)
            try:
                index = soilcodes.index(sl.soilcode)
                cbSoillayers.setCurrentIndex(index)
            except Exception as e:
                cbSoillayers.setCurrentIndex(0)
                print(
                    f"Error,could not find soilname '{sl.soilcode}' in the given resources, got error '{e}'"
                )

            cbSoillayers.currentIndexChanged.connect(self._update_figure)
            self.twSoillayers.setCellWidget(i, 2, cbSoillayers)  
        
        # connect to listen to changes again
        self.twSoillayers.cellChanged.connect(self.onTwSoillayersCellChanged)          

    def set_cpts(self, cpts):
        assert len(cpts) > 0
        self._cpts = cpts
        self._selected_index = 0
        sp1 = self._database.get_cpt_interpretation(self._cpt_ids[self._selected_index])
        if sp1:
            self._soilprofile_to_table(sp1)
        self._update_figure()
        

    def set_cpt_ids(self, cpt_ids):
        self._cpt_ids = cpt_ids

    def add_to_table(self, value: float):
        nrows = self.twSoillayers.rowCount()
        lastvalue = None
        if nrows > 0:
            item = self.twSoillayers.item(nrows-1, 1)
            if item is not None:
                lastvalue = float(self.twSoillayers.item(nrows-1, 1).text())

        if nrows == 0: # first entry
            self.twSoillayers.setRowCount(1)
            self.twSoillayers.setItem(0, 0, QtWidgets.QTableWidgetItem(f"{value:.2f}"))
            return
                    
        if lastvalue is None: # fill in the bottom value                         
            self.twSoillayers.setItem(self.twSoillayers.rowCount()-1, 1, QtWidgets.QTableWidgetItem(f"{value:.2f}"))                
        else: # create a new row and add the top from the previous line and the bottom from the clicked point
            self.twSoillayers.setRowCount(self.twSoillayers.rowCount() + 1)
            self.twSoillayers.setItem(self.twSoillayers.rowCount()-1, 0, QtWidgets.QTableWidgetItem(f"{lastvalue}"))
            self.twSoillayers.setItem(self.twSoillayers.rowCount()-1, 1, QtWidgets.QTableWidgetItem(f"{value:.2f}"))

        soilcodes = [s.code for s in self._soil_collection.soils]
        cbSoillayers = QtWidgets.QComboBox()
        cbSoillayers.addItems(soilcodes)
        cbSoillayers.currentIndexChanged.connect(self._update_figure)
        self.twSoillayers.setCellWidget(self.twSoillayers.rowCount()-1,2,cbSoillayers)
        
    
    def remove_last_from_table(self):
        if self.twSoillayers.rowCount() > 0:
            self.twSoillayers.setRowCount(self.twSoillayers.rowCount()-1)    
            self._update_figure()

    def onFigureMouseClicked(self, e):
        """Event that is called if the mouse is clicked within the figure"""
        if e.button == MouseButton.RIGHT:
            self.remove_last_from_table()
        elif e.button == MouseButton.LEFT:
            self.add_to_table(e.ydata)
            self._update_figure()            

    def _update_figure(self):
        self._figure.clear()
        self._canvas.draw()
        
        # draw your own stuff because it gets annoying
        cpt = self._cpts[self._selected_index]
        data = cpt.as_dataframe()

        # self._figure = Figure()
        # self._figure.set_tight_layout(True)

        spec = gridspec.GridSpec(ncols=2, nrows=1, width_ratios=[3, 1])
        ax_qc = self._figure.add_subplot(spec[0, :1])
        ax_qc.set_xlim(0, 20)
        ax_qc.set_ylim(cpt.bottom - 0.5, cpt.zid + 0.5)
        ax_qc.grid(which="both")
        data.plot(x="qc", y="z", ax=ax_qc, label="qc [MPa]")

        ax_fr = self._figure.add_subplot(spec[0, 1], sharey=ax_qc)
        ax_fr.set_xlim(0, 10)
        data.plot(x="fr", y="z", ax=ax_fr, label="fr [%]")

        ax_qc.grid(which="both")
        ax_fr.grid(which="both")

        sp1 = self._table_to_soilprofile1()        
        colordict = self._soil_collection.get_color_dict()
        for soil_layer in sp1.soillayers:
            pg = Polygon(
                [
                    (0, soil_layer.top),
                    (20, soil_layer.top),
                    (20, soil_layer.bottom),
                    (0, soil_layer.bottom),
                ],
                color=colordict[soil_layer.soilcode],
                alpha=0.7,
            )
            ax_qc.add_patch(pg)
            ax_qc.text(0, soil_layer.bottom, soil_layer.soilcode)

        self._figure.suptitle(f"{cpt.name}")
        self._canvas.draw()

    
